<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Connect 4 - IA com Minimax</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 800px;
            width: 100%;
        }

        h1 {
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .difficulty-selector, .game-info {
            background: rgba(255, 255, 255, 0.2);
            padding: 10px 15px;
            border-radius: 10px;
            border: none;
            color: white;
        }

        select {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 14px;
        }

        select option {
            background: #333;
            color: white;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(7, 60px);
            grid-template-rows: repeat(6, 60px);
            gap: 5px;
            justify-content: center;
            margin: 20px auto;
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 15px;
        }

        .cell {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            position: relative;
            overflow: hidden;
        }

        .cell:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(255, 255, 255, 0.3);
        }

        .cell.player1 {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
        }

        .cell.player2 {
            background: linear-gradient(135deg, #4834d4, #686de0);
            color: white;
            box-shadow: 0 4px 15px rgba(72, 52, 212, 0.4);
        }

        .cell.empty {
            background: rgba(255, 255, 255, 0.1);
            border: 2px dashed rgba(255, 255, 255, 0.3);
        }

        .winner-highlight {
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .status {
            font-size: 1.5em;
            margin: 20px 0;
            font-weight: bold;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        }

        .reset-btn {
            background: linear-gradient(135deg, #00d2ff, #3a7bd5);
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 16px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 210, 255, 0.3);
        }

        .reset-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 210, 255, 0.4);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.15);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
        }

        .ai-thinking {
            color: #ffd700;
            font-style: italic;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.5; }
        }

        .ranking {
            margin-top: 20px;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 15px;
        }

        .ranking h3 {
            margin-bottom: 15px;
            color: #ffd700;
        }

        .ranking-list {
            text-align: left;
            max-height: 200px;
            overflow-y: auto;
        }

        .ranking-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>üî¥ Connect 4 - IA Minimax üîµ</h1>
        
        <div class="controls">
            <div class="difficulty-selector">
                <label for="difficulty">Dificuldade da IA:</label>
                <select id="difficulty">
                    <option value="2">F√°cil (Prof. 2)</option>
                    <option value="4" selected>M√©dio (Prof. 4)</option>
                    <option value="6">Dif√≠cil (Prof. 6)</option>
                </select>
            </div>
            
            <div class="game-info">
                <span>Jogador: üî¥ | IA: üîµ</span>
            </div>
        </div>

        <div class="status" id="status">Sua vez! Clique em uma coluna</div>
        
        <div class="board" id="board"></div>
        
        <button class="reset-btn" onclick="resetGame()">üîÑ Novo Jogo</button>

        <div class="stats">
            <div class="stat-card">
                <h4>Vit√≥rias Jogador</h4>
                <div id="playerWins">0</div>
            </div>
            <div class="stat-card">
                <h4>Vit√≥rias IA</h4>
                <div id="aiWins">0</div>
            </div>
            <div class="stat-card">
                <h4>Empates</h4>
                <div id="draws">0</div>
            </div>
            <div class="stat-card">
                <h4>Jogadas Analisadas</h4>
                <div id="movesAnalyzed">0</div>
            </div>
        </div>

        <div class="ranking">
            <h3>üèÜ Ranking de Jogadores</h3>
            <div class="ranking-list" id="rankingList">
                <div class="ranking-item">
                    <span>IA Minimax</span>
                    <span id="aiScore">0 pts</span>
                </div>
                <div class="ranking-item">
                    <span>Jogador Humano</span>
                    <span id="playerScore">0 pts</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============ ESTRUTURAS DE DADOS ============
        
        // 1. √ÅRVORE (N√≥ da √°rvore Minimax)
        class TreeNode {
            constructor(board, move = null, depth = 0) {
                this.board = board;
                this.move = move;
                this.depth = depth;
                this.children = [];
                this.value = null;
                this.isTerminal = false;
            }
            
            addChild(child) {
                this.children.push(child);
            }
            
            isLeaf() {
                return this.children.length === 0;
            }
        }
        
        // 2. LISTA ORDENADA para Ranking (com MergeSort)
        class SortedList {
            constructor() {
                this.items = [];
            }
            
            // Inserir mantendo ordem
            insert(item) {
                const index = this.findInsertPosition(item);
                this.items.splice(index, 0, item);
            }
            
            findInsertPosition(item) {
                let left = 0;
                let right = this.items.length;
                
                while (left < right) {
                    const mid = Math.floor((left + right) / 2);
                    if (this.items[mid].score > item.score) {
                        left = mid + 1;
                    } else {
                        right = mid;
                    }
                }
                return left;
            }
            
            // MergeSort para ordena√ß√£o completa
            mergeSort(arr = this.items) {
                if (arr.length <= 1) return arr;
                
                const mid = Math.floor(arr.length / 2);
                const left = this.mergeSort(arr.slice(0, mid));
                const right = this.mergeSort(arr.slice(mid));
                
                return this.merge(left, right);
            }
            
            merge(left, right) {
                const result = [];
                let i = 0, j = 0;
                
                while (i < left.length && j < right.length) {
                    if (left[i].score >= right[j].score) {
                        result.push(left[i]);
                        i++;
                    } else {
                        result.push(right[j]);
                        j++;
                    }
                }
                
                return result.concat(left.slice(i)).concat(right.slice(j));
            }
            
            getTop(n = 5) {
                return this.items.slice(0, n);
            }
            
            update(name, score) {
                const existing = this.items.find(item => item.name === name);
                if (existing) {
                    existing.score = score;
                    this.items = this.mergeSort();
                } else {
                    this.insert({ name, score });
                }
            }
        }

        // ============ VARI√ÅVEIS GLOBAIS ============
        
        const ROWS = 6;
        const COLS = 7;
        const PLAYER = 1;
        const AI = 2;
        const EMPTY = 0;
        
        let board = [];
        let currentPlayer = PLAYER;
        let gameOver = false;
        let difficulty = 4;
        let movesAnalyzed = 0;
        
        // Estat√≠sticas
        let stats = {
            playerWins: 0,
            aiWins: 0,
            draws: 0
        };
        
        // Ranking usando nossa lista ordenada
        const ranking = new SortedList();
        ranking.insert({ name: "IA Minimax", score: 0 });
        ranking.insert({ name: "Jogador Humano", score: 0 });

        // ============ INICIALIZA√á√ÉO ============
        
        function initGame() {
            board = Array(ROWS).fill().map(() => Array(COLS).fill(EMPTY));
            currentPlayer = PLAYER;
            gameOver = false;
            movesAnalyzed = 0;
            createBoard();
            updateStatus("Sua vez! Clique em uma coluna");
            updateStats();
        }
        
        function createBoard() {
            const boardElement = document.getElementById('board');
            boardElement.innerHTML = '';
            
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell empty';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.addEventListener('click', () => handleCellClick(col));
                    boardElement.appendChild(cell);
                }
            }
        }

        // ============ L√ìGICA DO JOGO ============
        
        function handleCellClick(col) {
            if (gameOver || currentPlayer !== PLAYER) return;
            
            if (makeMove(col, PLAYER)) {
                updateBoard();
                
                if (checkWin(board, PLAYER)) {
                    endGame("üéâ Voc√™ venceu!", PLAYER);
                } else if (isBoardFull(board)) {
                    endGame("‚öñÔ∏è Empate!", null);
                } else {
                    currentPlayer = AI;
                    updateStatus('<span class="ai-thinking">ü§ñ IA pensando...</span>');
                    
                    // Delay para mostrar que a IA est√° "pensando"
                    setTimeout(() => {
                        aiMove();
                    }, 500);
                }
            }
        }
        
        function makeMove(col, player) {
            for (let row = ROWS - 1; row >= 0; row--) {
                if (board[row][col] === EMPTY) {
                    board[row][col] = player;
                    return true;
                }
            }
            return false;
        }
        
        function aiMove() {
            const startTime = performance.now();
            movesAnalyzed = 0;
            
            // Criar n√≥ raiz da √°rvore
            const rootNode = new TreeNode(copyBoard(board));
            
            // Executar Minimax
            const bestMove = minimax(rootNode, difficulty, true);
            
            const endTime = performance.now();
            console.log(`IA analisou ${movesAnalyzed} jogadas em ${(endTime - startTime).toFixed(2)}ms`);
            
            if (bestMove !== null && makeMove(bestMove, AI)) {
                updateBoard();
                
                if (checkWin(board, AI)) {
                    endGame("ü§ñ IA venceu!", AI);
                } else if (isBoardFull(board)) {
                    endGame("‚öñÔ∏è Empate!", null);
                } else {
                    currentPlayer = PLAYER;
                    updateStatus("Sua vez! Clique em uma coluna");
                }
            }
            
            updateStats();
        }

        // ============ ALGORITMO MINIMAX ============
        
        function minimax(node, depth, isMaximizing) {
            movesAnalyzed++;
            
            // Condi√ß√µes de parada
            if (depth === 0 || checkWin(node.board, AI) || checkWin(node.board, PLAYER) || isBoardFull(node.board)) {
                return evaluateBoard(node.board);
            }
            
            const player = isMaximizing ? AI : PLAYER;
            let bestValue = isMaximizing ? -Infinity : Infinity;
            let bestMove = null;
            
            // Gerar filhos (jogadas poss√≠veis)
            for (let col = 0; col < COLS; col++) {
                if (isValidMove(node.board, col)) {
                    const newBoard = copyBoard(node.board);
                    
                    // Fazer jogada
                    for (let row = ROWS - 1; row >= 0; row--) {
                        if (newBoard[row][col] === EMPTY) {
                            newBoard[row][col] = player;
                            break;
                        }
                    }
                    
                    // Criar n√≥ filho
                    const childNode = new TreeNode(newBoard, col, node.depth + 1);
                    node.addChild(childNode);
                    
                    // Recurs√£o
                    const value = minimax(childNode, depth - 1, !isMaximizing);
                    
                    if (isMaximizing) {
                        if (value > bestValue) {
                            bestValue = value;
                            bestMove = col;
                        }
                    } else {
                        if (value < bestValue) {
                            bestValue = value;
                            bestMove = col;
                        }
                    }
                }
            }
            
            // Se estamos na raiz, retornar a melhor jogada
            if (node.depth === 0) {
                return bestMove;
            }
            
            return bestValue;
        }
        
        // Fun√ß√£o de avalia√ß√£o heur√≠stica
        function evaluateBoard(board) {
            if (checkWin(board, AI)) return 1000;
            if (checkWin(board, PLAYER)) return -1000;
            if (isBoardFull(board)) return 0;
            
            let score = 0;
            
            // Avaliar todas as sequ√™ncias poss√≠veis de 4
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    // Horizontal
                    if (col <= COLS - 4) {
                        score += evaluateSequence(board, row, col, 0, 1);
                    }
                    // Vertical
                    if (row <= ROWS - 4) {
                        score += evaluateSequence(board, row, col, 1, 0);
                    }
                    // Diagonal \
                    if (row <= ROWS - 4 && col <= COLS - 4) {
                        score += evaluateSequence(board, row, col, 1, 1);
                    }
                    // Diagonal /
                    if (row >= 3 && col <= COLS - 4) {
                        score += evaluateSequence(board, row, col, -1, 1);
                    }
                }
            }
            
            return score;
        }
        
        function evaluateSequence(board, row, col, deltaRow, deltaCol) {
            let aiCount = 0;
            let playerCount = 0;
            
            for (let i = 0; i < 4; i++) {
                const r = row + i * deltaRow;
                const c = col + i * deltaCol;
                
                if (board[r][c] === AI) aiCount++;
                else if (board[r][c] === PLAYER) playerCount++;
            }
            
            // Se ambos jogadores t√™m pe√ßas na sequ√™ncia, n√£o vale nada
            if (aiCount > 0 && playerCount > 0) return 0;
            
            // Pontua√ß√£o baseada no n√∫mero de pe√ßas
            if (aiCount === 4) return 1000;
            if (aiCount === 3) return 100;
            if (aiCount === 2) return 10;
            if (aiCount === 1) return 1;
            
            if (playerCount === 4) return -1000;
            if (playerCount === 3) return -100;
            if (playerCount === 2) return -10;
            if (playerCount === 1) return -1;
            
            return 0;
        }

        // ============ FUN√á√ïES AUXILIARES ============
        
        function checkWin(board, player) {
            // Verificar todas as dire√ß√µes poss√≠veis
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    if (board[row][col] === player) {
                        // Horizontal
                        if (col <= COLS - 4 && 
                            board[row][col + 1] === player &&
                            board[row][col + 2] === player &&
                            board[row][col + 3] === player) {
                            highlightWinningCells([[row, col], [row, col + 1], [row, col + 2], [row, col + 3]]);
                            return true;
                        }
                        
                        // Vertical
                        if (row <= ROWS - 4 &&
                            board[row + 1][col] === player &&
                            board[row + 2][col] === player &&
                            board[row + 3][col] === player) {
                            highlightWinningCells([[row, col], [row + 1, col], [row + 2, col], [row + 3, col]]);
                            return true;
                        }
                        
                        // Diagonal \
                        if (row <= ROWS - 4 && col <= COLS - 4 &&
                            board[row + 1][col + 1] === player &&
                            board[row + 2][col + 2] === player &&
                            board[row + 3][col + 3] === player) {
                            highlightWinningCells([[row, col], [row + 1, col + 1], [row + 2, col + 2], [row + 3, col + 3]]);
                            return true;
                        }
                        
                        // Diagonal /
                        if (row >= 3 && col <= COLS - 4 &&
                            board[row - 1][col + 1] === player &&
                            board[row - 2][col + 2] === player &&
                            board[row - 3][col + 3] === player) {
                            highlightWinningCells([[row, col], [row - 1, col + 1], [row - 2, col + 2], [row - 3, col + 3]]);
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        function highlightWinningCells(cells) {
            cells.forEach(([row, col]) => {
                const index = row * COLS + col;
                const cell = document.getElementById('board').children[index];
                cell.classList.add('winner-highlight');
            });
        }
        
        function isBoardFull(board) {
            return board[0].every(cell => cell !== EMPTY);
        }
        
        function isValidMove(board, col) {
            return board[0][col] === EMPTY;
        }
        
        function copyBoard(board) {
            return board.map(row => [...row]);
        }
        
        function updateBoard() {
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const index = row * COLS + col;
                    const cell = document.getElementById('board').children[index];
                    
                    cell.className = 'cell';
                    if (board[row][col] === PLAYER) {
                        cell.classList.add('player1');
                        cell.textContent = 'üî¥';
                    } else if (board[row][col] === AI) {
                        cell.classList.add('player2');
                        cell.textContent = 'üîµ';
                    } else {
                        cell.classList.add('empty');
                        cell.textContent = '';
                    }
                }
            }
        }
        
        function updateStatus(message) {
            document.getElementById('status').innerHTML = message;
        }
        
        function endGame(message, winner) {
            gameOver = true;
            updateStatus(message);
            
            // Atualizar estat√≠sticas
            if (winner === PLAYER) {
                stats.playerWins++;
                updateRanking("Jogador Humano", 3);
            } else if (winner === AI) {
                stats.aiWins++;
                updateRanking("IA Minimax", 3);
            } else {
                stats.draws++;
                updateRanking("Jogador Humano", 1);
                updateRanking("IA Minimax", 1);
            }
            
            updateStats();
        }
        
        function updateRanking(playerName, points) {
            const current = ranking.items.find(item => item.name === playerName);
            if (current) {
                current.score += points;
            }
            
            // Reordenar usando MergeSort
            ranking.items = ranking.mergeSort();
            
            // Atualizar display
            document.getElementById('aiScore').textContent = 
                ranking.items.find(item => item.name === "IA Minimax").score + " pts";
            document.getElementById('playerScore').textContent = 
                ranking.items.find(item => item.name === "Jogador Humano").score + " pts";
        }
        
        function updateStats() {
            document.getElementById('playerWins').textContent = stats.playerWins;
            document.getElementById('aiWins').textContent = stats.aiWins;
            document.getElementById('draws').textContent = stats.draws;
            document.getElementById('movesAnalyzed').textContent = movesAnalyzed;
        }
        
        function resetGame() {
            initGame();
        }
        
        // Event listeners
        document.getElementById('difficulty').addEventListener('change', function() {
            difficulty = parseInt(this.value);
        });

        // Inicializar jogo
        initGame();
    </script>
</body>
</html>